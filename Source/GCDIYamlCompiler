#!/usr/bin/env ruby
#
# GCDependencyInjection
#
# Created by Jake Wise on 13/05/2016.
# Copyright (c) 2016 GroovyCarrot Ltd. All rights reserved.
#
# You are permitted to use, modify, and distribute this file in accordance with
# the terms of the license agreement accompanying it.
#

require 'yaml'
require 'optparse'

class ContainerYamlCompiler
  @@output
  @@definitionParser
  @@parser

  def initialize(definitionParser, parser)
    @definitionParser = definitionParser
    @parser = parser
  end

  def compile(klass, instruction)
    implementation = []

    if instruction['Parameters'].is_a?(Hash)
      instruction['Parameters'].each do |parameter, value|
        implementation.push(@parser.setParameter(parameter, value))
      end
    end

    if instruction['Services'].is_a?(Hash)
      var = 'serviceDefinition'
      implementation.push('GCDIDefinitionBlock ' + var + ';')

      instruction['Services'].each do |service, definition|
        if definition.is_a?(String)
          if definition[0, 1] == '@'
            implementation.push(@parser.setAlias(service, definition))
          end
        else
          implementation.push(*@definitionParser.parseServiceDefinition(var, definition, @parser))
          implementation.push(@parser.setService(service, var))
        end
      end
    end

    @parser.writeImplementationStart(@output, klass)
    self.outputLinesWithIndentation(implementation, 2)
    @parser.writeImplementationEnd(@output)
  end

  def setOutput(output)
    @output = output
    # Write file header.
    @output.puts '#import <GCDependencyInjection/GCDependencyInjection.h>'
    @output.puts ''
  end

  def getOutput()
    return @output
  end

  def outputLinesWithIndentation(lines, n)
    @output.puts (' ' * n) + lines.join("\n" + (' ' * n))
  end
end

class ContainerDefinitionParser
  @@lines
  @@parser

  def parseServiceDefinition(variable, definition, parser)
    @lines = []
    @parser = parser

    @lines.push(variable + ' = ^(GCDIDefinition *definition) {')

    if definition['Class']
      @lines.push(@parser.callSetterMethod('definition', 'setClassName', definition['Class']))
    end

    if definition['Factory']
      @lines.push(@parser.callSetterMethod('definition', 'setFactory', definition['Factory']))
    end

    if definition['Initializer']
      @lines.push(@parser.callSetterMethod('definition', 'setInitializer', definition['Initializer']))
    elsif definition['Factory']
      raise 'A selector must be specified when using a factory service.'
    end

    if definition['Arguments']
      @lines.push(@parser.callSetterMethod('definition', 'setArguments', definition['Arguments']))
    end

    if definition['Setters']
      @lines.push(@parser.callSetterMethod('definition', 'setSetters', definition['Setters']))
    end

    if definition['MethodCalls']
      definition['MethodCalls'].each do |methodCall|
        if methodCall.is_a?(Hash)
          @lines.push(@parser.callSetterMethod('definition', 'addMethodCall', @parser.createMethodCall(methodCall['Selector'], methodCall['Arguments']), true))
        else
          @lines.push(@parser.callSetterMethod('definition', 'addMethodCall', @parser.createMethodCall(methodCall[0], methodCall[1]), true))
        end
      end
    end

    if definition['Tags']
      @lines.push(@parser.callSetterMethod('definition', 'setTags', definition['Tags']))
    end

    if definition['Shared']
      @lines.push(@parser.callSetterMethod('definition', 'setShared', definition['Shared']))
    end

    if definition['Synthetic']
      @lines.push(@parser.callSetterMethod('definition', 'setSynthetic', definition['Synthetic']))
    end

    @lines.push('};')

    return @lines
  end
end

class CodeTranslator
  def parse(value)
    if value.is_a?(Array)
      resolved = []
      value.each do |val|
        resolved.push(self.parse(val))
      end
      return '@[' + resolved.join(', ') + ']'
    elsif value.is_a?(Hash)
      resolved = '@{'
      value.each do |key, val|
        resolved += self.parse(key) + ': ' + self.parse(val) + ', '
      end
      return resolved[0, resolved.length - 2] + '}'
    elsif value.is_a?(Numeric)
      return "@#{value}"
    elsif [true, false].include?(value)
      return value == true ? 'TRUE' : 'FALSE'
    elsif value.is_a?(String) && value[0, 1] == '@'
      service = nil
      invalidBehaviour = nil

      if value[0, 2] == '@@'
        return '@"' + value[1, value.length - 1] + '"'
      elsif value[0, 2] == '@?'
        service = value[2, value.length - 2]
        invalidBehaviour = 'kNilOnInvalidReference'
      else
        service = value[1, value.length - 1]
        invalidBehaviour = 'kExceptionOnInvalidReference'
      end

      return self.createServiceReference(service, invalidBehaviour)
    end
    return '@"' + value + '"'
  end

  def setParameter(parameter, value)
    return '[self setParameter:' + self.parse(parameter) + ' value:' + self.parse(value) + '];'
  end

  def setAlias(service, definition)
    return '[self setAlias:' + self.parse(service) + ' to:' + self.parse(definition[1, definition.length - 1]) + '];'
  end

  def setService(service, var)
    return '[self setService:' + self.parse(service) + ' definition:' + var + '];'
  end

  def callSetterMethod(variable, method, argument, parsed = false)
    return '[' + variable + ' ' + method + ':' + (parsed ? argument : self.parse(argument)) + '];'
  end

  def createMethodCall(selector, arguments)
    return '[GCDIMethodCall methodCallForSelector:@selector(' + selector + ') andArguments:' + self.parse(arguments) + ']'
  end

  def createServiceReference(service, invalidBehaviour)
    return '[GCDIReference referenceForServiceId:@"' + service + '" invalidBehaviourType:' + invalidBehaviour + ']'
  end

  def writeImplementationStart(output, klass)
    output.puts '@interface ' + klass + ' : GCDIDefinitionContainer'
    output.puts '@end'
    output.puts '@implementation ' + klass + ' (Yaml)'
    output.puts '- (void)yamlProvisionContainer {'
  end

  def writeImplementationEnd(output)
    output.puts '}'
    output.puts '@end'
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: GCDIYamlCompiler <file> [<file>...] [options]"

  opts.on("-o", "--output [file]", "Specify output file") do |o|
    options[:output] = File.expand_path(o)
    options[:outputIsDir] = File.directory?(o)
  end
end.parse!

writer = ContainerYamlCompiler.new(ContainerDefinitionParser.new, CodeTranslator.new)

if options[:output] && !options[:outputIsDir]
  writer.setOutput(File.open(options[:output], 'w+'))
end

ARGV.each do |file|
  file = File.expand_path(file)

  if !File.exists?(file)
    puts 'File not found: ' + file + '. Skipping.'
    next
  end

  # Assume the filename is the name of the class that the implementation is for.
  klass = File.basename(file, '.*')

  instruction = YAML.load_file(file)

  if !instruction.is_a?(Hash)
    instruction = {}
  elsif instruction['ContainerClass'] && instruction['ContainerClass'].is_a?(String)
    # Allow the YAML file to define the class of the container implementation to
    # write to with ContainerClass key.
    klass = instruction['ContainerClass']
  end

  if !options[:output]
    # Write file to the source file directory.
    writer.setOutput(File.open(File.dirname(file) + '/' + klass + '.m', 'w+'))
  elsif options[:outputIsDir]
    # Write the file to the specified output directory.
    writer.setOutput(File.open(options[:output] + '/' + klass + '.m', 'w+'))
  else
    # Assume we're writing many implementations to the one file, add a space.
    writer.getOutput().puts ''
  end

  writer.compile(klass, instruction)

  puts 'Output ' + klass + ' (Yaml) implementation to ' + File.expand_path(writer.getOutput().path)
end
