#!/usr/bin/env ruby
#
# GCDependencyInjection
#
# Created by Jake Wise on 13/05/2016.
# Copyright (c) 2016 GroovyCarrot Ltd. All rights reserved.
#
# You are permitted to use, modify, and distribute this file in accordance with
# the terms of the license agreement accompanying it.
#

require 'yaml'
require 'optparse'

class ContainerYamlCompiler
  @@output
  @@definitionParser
  @@serviceResolver

  def initialize(definitionParser, serviceResolver)
    @definitionParser = definitionParser
    @serviceResolver = serviceResolver
  end

  def compile(klass, instruction)
    implementation = []

    if instruction['Parameters'].is_a?(Hash)
      instruction['Parameters'].each do |parameter, value|
        implementation.push('[self setParameter:@"' + parameter + '" value:' + @serviceResolver.resolveServices(value) + '];')
      end
    end

    if instruction['Services'].is_a?(Hash)
      var = 'serviceDefinition'
      implementation.push('GCDIDefinitionBlock ' + var + ';')

      instruction['Services'].each do |service, definition|
        if definition.is_a?(String)
          if definition[0, 1] == '@'
            implementation.push('[self setAlias:@"' + service + '" to:@"' + definition[1, definition.length - 1] + '"];')
          end
        else
          implementation.push(*@definitionParser.parseServiceDefinition(var, definition, @serviceResolver))
          implementation.push('[self setService:@"' + service + '" definition:' + var + '];')
        end
      end
    end

    self.writeImplementationStart(klass)
    self.outputLinesWithIndentation(implementation, 2)
    self.writeImplementationEnd()
  end

  def setOutput(output)
    @output = output
    # Write file header.
    @output.puts '#import <GCDependencyInjection/GCDependencyInjection.h>'
    @output.puts ''
  end

  def getOutput()
    return @output
  end

  def outputLinesWithIndentation(lines, n)
    @output.puts (' ' * n) + lines.join("\n" + (' ' * n))
  end

  def writeImplementationStart(klass)
    @output.puts '@interface ' + klass + ' : GCDIDefinitionContainer'
    @output.puts '@end'
    @output.puts '@implementation ' + klass + ' (Yaml)'
    @output.puts '- (void)yamlProvisionContainer {'
  end

  def writeImplementationEnd()
    @output.puts '}'
    @output.puts '@end'
  end
end

class ContainerDefinitionParser
  def parseServiceDefinition(variable, definition, serviceResolver)
    lines = []

    lines.push(variable + ' = ^(GCDIDefinition *def) {')

    if definition['Class']
      lines.push('[def setClassName:@"' + definition['Class'] + '"];')
    end

    if definition['Factory']
      lines.push('[def setFactory:' + serviceResolver.resolveServices(definition['Factory']) + '];')
    end

    if definition['Selector']
      lines.push('[def setInitializer:@"' + definition['Selector'] + '"];')
    elsif definition['Factory']
      raise 'A selector must be specified when using a factory service.'
    end

    if definition['Arguments']
      lines.push('[def setArguments:' + serviceResolver.resolveServices(definition['Arguments']) + '];')
    end

    if definition['Setters']
      lines.push('[def setSetters:' + serviceResolver.resolveServices(definition['Setters']) + '];')
    end

    if definition['MethodCalls']
      definition['MethodCalls'].each do |methodCall|
        if methodCall.is_a?(Hash)
          lines.push('[def addMethodCall:[GCDIMethodCall methodCallForSelector:@selector(' + methodCall['Selector'] + ') andArguments:' + serviceResolver.resolveServices(methodCall['Arguments']) + ']];')
        else
          lines.push('[def addMethodCall:[GCDIMethodCall methodCallForSelector:@selector(' + methodCall[0] + ') andArguments:' + serviceResolver.resolveServices(methodCall[1]) + ']];')
        end
      end
    end

    if definition['Tags']
      lines.push('[def setTags:' + serviceResolver.resolveServices(definition['Tags']) + '];')
    end

    lines.push('};')

    return lines
  end
end

class ServiceResolver
  def resolveServices(value)
    if value.is_a? Array
      resolved = []
      value.each do |val|
        resolved.push(self.resolveServices(val))
      end
      return '@[' + resolved.join(', ') + ']'
    elsif value.is_a? Hash
      resolved = '@{'
      value.each do |key, val|
        resolved += '@"' + key + '": ' + self.resolveServices(val) + ', '
      end
      return resolved[0, resolved.length - 2] + '}'
    elsif value.is_a?(String) && value[0, 1] == '@'
      service = nil
      invalidBehaviour = nil

      if value[0, 2] == '@@'
        return '@"' + value[1, value.length - 1] + '"'
      elsif value[0, 2] == '@?'
        service = value[2, value.length - 2]
        invalidBehaviour = 'kNilOnInvalidReference'
      else
        service = value[1, value.length - 1]
        invalidBehaviour = 'kExceptionOnInvalidReference'
      end

      return '[GCDIReference referenceForServiceId:@"' + service + '" invalidBehaviourType:' + invalidBehaviour + ']'
    end
    return '@"' + value + '"'
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: GCDIYamlCompiler <file> [<file>...] [options]"

  opts.on("-o", "--output [file]", "Specify output file") do |o|
    options[:output] = File.expand_path(o)
    options[:outputIsDir] = File.directory?(o)
  end
end.parse!

writer = ContainerYamlCompiler.new(ContainerDefinitionParser.new, ServiceResolver.new)

if options[:output] && !options[:outputIsDir]
  writer.setOutput(File.open(options[:output], 'w+'))
end

ARGV.each do |file|
  file = File.expand_path(file)

  if !File.exists?(file)
    puts 'File not found: ' + file + '. Skipping.'
    next
  end

  # Assume the filename is the name of the class that the implementation is for.
  klass = File.basename(file, '.*')

  instruction = YAML.load_file(file)

  if !instruction.is_a?(Hash)
    instruction = {}
  elsif instruction['ContainerClass'] && instruction['ContainerClass'].is_a?(String)
    # Allow the YAML file to define the class of the container implementation to
    # write to with ContainerClass key.
    klass = instruction['ContainerClass']
  end

  if !options[:output]
    # Write file to the source file directory.
    writer.setOutput(File.open(File.dirname(file)) + '/' + klass + '.m', 'w+')
  elsif options[:outputIsDir]
    # Write the file to the specified output directory.
    writer.setOutput(File.open(options[:output] + '/' + klass + '.m', 'w+'))
  else
    # Assume we're writing many implementations to the one file, add a space.
    writer.getOutput().puts ''
  end

  writer.compile(klass, instruction)

  puts 'Output ' + klass + ' (Yaml) implementation to ' + File.expand_path(writer.getOutput().path)
end
